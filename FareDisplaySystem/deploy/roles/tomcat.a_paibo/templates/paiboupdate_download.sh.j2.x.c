#if 0
	shc Version 3.8.9b, Generic Script Compiler
	Copyright (c) 1994-2015 Francisco Rosales <frosal@fi.upm.es>

	shc -v -r -T -f tomcat.a_paibo/templates/paiboupdate_download.sh.j2 
#endif

static  char data [] = 
#define      rlax_z	1
#define      rlax	((&data[0]))
	"\023"
#define      pswd_z	256
#define      pswd	((&data[61]))
	"\040\336\245\212\323\375\211\143\233\353\150\304\075\266\240\257"
	"\117\011\261\165\216\312\136\015\213\023\050\040\032\026\116\073"
	"\364\364\305\310\361\117\054\214\072\225\121\170\113\362\047\233"
	"\373\330\020\211\243\157\227\056\202\300\117\235\037\015\002\142"
	"\026\221\373\253\356\256\113\334\226\325\026\053\237\336\224\375"
	"\377\300\372\110\357\357\116\213\227\175\375\266\212\377\031\241"
	"\221\025\115\177\303\231\134\132\156\163\206\016\121\032\014\121"
	"\332\006\231\312\366\350\125\215\145\122\103\360\122\134\221\343"
	"\162\336\143\065\167\300\220\346\063\026\364\204\060\001\325\013"
	"\010\157\325\376\127\053\213\275\176\316\255\321\053\077\265\236"
	"\035\030\324\225\331\144\174\014\173\161\221\253\162\147\267\172"
	"\326\215\170\056\270\003\353\067\322\230\010\376\327\276\234\365"
	"\327\161\213\260\325\007\275\120\170\116\374\352\266\263\145\215"
	"\101\335\273\371\341\246\061\264\076\072\263\026\370\120\013\317"
	"\301\226\200\226\236\075\347\026\214\344\001\102\230\146\317\331"
	"\104\212\323\046\061\004\333\160\077\216\206\067\336\222\007\240"
	"\051\207\067\307\305\036\336\121\003\337\224\233\106\144\164\213"
	"\356\110\262\040\114\215\220\213\033\026\303\372\251\313\233\322"
	"\123\322\231\030\361\167\152\364\127\376\220\236\142\005\051\121"
	"\115\333\161\231\150\001\045\204\030\351\177\301\326\235\330\313"
	"\221\236\224\202\355\300\017"
#define      date_z	1
#define      date	((&data[328]))
	"\144"
#define      msg2_z	19
#define      msg2	((&data[332]))
	"\310\074\116\123\247\342\203\152\254\142\363\305\152\120\246\051"
	"\227\046\367\333\163\166\241"
#define      inlo_z	3
#define      inlo	((&data[352]))
	"\326\117\010"
#define      opts_z	1
#define      opts	((&data[355]))
	"\245"
#define      shll_z	10
#define      shll	((&data[356]))
	"\252\371\136\014\343\130\250\071\316\257\334\007"
#define      xecc_z	15
#define      xecc	((&data[370]))
	"\361\123\115\133\074\310\366\326\317\313\345\123\201\305\325\134"
	"\012\147\164\101"
#define      lsto_z	1
#define      lsto	((&data[388]))
	"\257"
#define      tst1_z	22
#define      tst1	((&data[394]))
	"\036\067\323\132\206\323\006\271\266\000\001\075\311\343\314\071"
	"\225\260\166\203\173\364\154\031\145\120\215"
#define      chk1_z	22
#define      chk1	((&data[419]))
	"\272\143\317\015\275\320\162\144\337\066\035\163\041\060\335\231"
	"\315\264\370\211\113\311\343\072\260\056\242"
#define      msg1_z	42
#define      msg1	((&data[453]))
	"\007\121\064\332\102\207\102\267\310\151\005\142\342\162\152\241"
	"\347\014\220\162\064\276\111\303\036\140\210\321\122\375\132\113"
	"\264\156\351\335\351\375\346\276\003\037\046\251\207\130\037\175"
	"\064\134\201\013\072\062\347\037\075"
#define      text_z	716
#define      text	((&data[561]))
	"\140\335\207\010\074\101\154\013\157\016\013\140\215\022\262\301"
	"\355\365\111\057\254\022\231\347\105\200\006\202\206\135\224\347"
	"\072\033\357\166\134\134\202\314\152\215\055\370\240\337\272\216"
	"\324\003\275\200\026\127\147\133\327\156\336\136\313\226\050\327"
	"\110\343\042\244\324\110\032\163\012\102\233\067\371\272\236\171"
	"\034\175\210\366\126\227\056\303\351\237\045\363\355\227\016\202"
	"\354\362\206\341\051\355\220\163\070\254\361\315\204\337\326\351"
	"\325\343\111\125\371\270\011\112\040\361\045\172\116\164\323\052"
	"\155\231\322\207\037\271\230\100\050\020\242\250\017\045\306\330"
	"\055\214\114\346\105\365\013\261\001\217\367\333\336\021\154\172"
	"\325\251\243\340\131\040\362\142\101\122\312\233\057\330\030\105"
	"\214\260\225\041\331\223\254\355\311\255\021\017\271\231\305\225"
	"\113\017\046\230\154\300\133\363\127\311\253\110\323\247\103\356"
	"\041\350\022\264\141\072\133\320\214\256\133\230\340\155\166\166"
	"\340\121\312\267\111\252\201\066\355\272\205\376\321\261\325\211"
	"\121\113\066\250\116\046\175\337\367\226\064\044\022\124\134\321"
	"\235\130\001\022\174\260\143\114\371\145\005\024\026\163\262\001"
	"\271\210\341\275\104\000\114\031\133\017\137\277\222\221\027\050"
	"\017\200\060\221\113\006\062\342\202\162\127\170\027\253\055\014"
	"\076\003\340\005\260\202\233\173\125\067\317\042\333\275\140\324"
	"\142\367\145\357\000\314\042\262\032\236\135\215\261\253\134\366"
	"\263\040\123\073\340\364\106\041\047\100\215\251\234\227\255\327"
	"\060\257\172\362\310\265\215\364\272\227\075\233\015\067\026\133"
	"\245\130\354\211\005\275\127\374\176\107\227\137\001\017\373\144"
	"\263\367\352\022\243\041\241\245\354\331\256\004\046\317\210\107"
	"\143\140\210\120\316\132\174\043\365\237\245\130\307\140\213\333"
	"\266\072\323\365\343\260\317\303\243\354\242\130\054\133\052\373"
	"\160\117\032\177\076\137\311\342\210\073\306\112\220\076\116\042"
	"\367\155\114\060\253\017\216\124\161\331\345\343\323\322\135\205"
	"\245\025\206\342\242\362\153\214\370\276\317\015\233\124\131\072"
	"\153\064\274\125\216\044\207\155\342\157\005\373\146\344\225\265"
	"\135\233\356\370\134\074\137\341\036\170\252\345\125\357\247\315"
	"\376\066\030\315\076\223\107\244\140\245\202\074\114\170\307\007"
	"\014\204\053\243\162\231\005\074\271\021\064\342\153\142\227\244"
	"\231\042\316\022\251\156\125\247\167\362\265\104\031\137\156\255"
	"\270\267\317\344\053\024\311\200\321\371\104\041\370\054\332\037"
	"\055\117\223\002\022\115\121\202\341\304\061\066\325\301\104\325"
	"\145\064\211\357\336\111\142\356\271\040\273\177\211\223\267\131"
	"\166\044\144\330\261\332\046\163\274\002\170\314\112\201\121\010"
	"\175\322\115\033\215\164\331\376\211\322\234\242\015\312\250\334"
	"\246\306\305\341\021\264\351\065\274\032\273\245\031\110\254\151"
	"\100\321\100\065\276\241\330\064\207\377\312\363\040\263\026\165"
	"\020\372\251\056\240\177\276\040\331\256\374\160\165\132\166\023"
	"\042\133\076\334\256\012\340\367\012\021\367\355\313\147\355\110"
	"\254\130\206\060\056\104\275\131\245\130\071\031\332\126\101\075"
	"\026\161\047\341\367\127\103\376\056\147\217\132\212\336\246\113"
	"\124\371\373\060\373\242\305\244\065\134\137\075\362\342\146\370"
	"\124\274\242\345\334\265\217\035\205\243\134\365\211\335\316\272"
	"\322\332\270\037\277\255\211\121\023\162\106\006\216\066\175\353"
	"\222\377\267\375\215"
#define      tst2_z	19
#define      tst2	((&data[1293]))
	"\303\260\274\230\233\064\316\334\030\122\354\325\066\060\174\106"
	"\172\160\012\040\370\105\050"
#define      chk2_z	19
#define      chk2	((&data[1314]))
	"\312\320\155\313\371\311\275\005\067\017\050\155\363\166\323\015"
	"\262\310\370\005\060"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask  = (unsigned long)&chkenv;
	mask ^= (unsigned long)getpid() * ~mask;
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];

	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	ret = chkenv(argc);
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
	varg[j++] = argv[0];		/* My own name at execution */
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
